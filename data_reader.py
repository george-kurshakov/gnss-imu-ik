import datetime as dt
import numpy as np

# Delay between GNSS and IMU timestamp, computed experimentally from cross-correlation [msec]
t_delay_msec = 750

class IMU_epoch:
    """
    An IMU epoch object.

    :ivar time: :class:`datetime` instance representing the UTC timestamp.
    :ivar acc: 3x1 :class:`numpy.array` specific force measured by the accelerometer [m/s^2].
    :ivar gyr: 3x1 :class:`numpy.array` angular rate measured by the gyroscope [rad/s].
    :ivar mag: 3x1 :class:`numpy.array` magnetic field measured by the magnetometer [G].
    :ivar quat: 3x1 :class:`numpy.array` es
    :cvar zupt: 0: no zero velocity, 1: zero velocity (set up by :func:`detect_zv`).
    """

    zupt = None

    def __init__(self, time, acc, gyr, mag, quat):
        self.time = time
        self.acc = acc
        self.gyr = gyr
        self.mag = mag
        self.quat = quat

    def print(self):
        """Print epoch data."""
        print(self.time)
        print("Acc = " + str(self.acc))
        print("Gyr = " + str(self.gyr))
        print("Mag = " + str(self.mag))
        print("Quat = " + str(self.quat))


class GNSS_epoch:
    """
    A GNSS epoch object.

    :ivar time: :class:`datetime` instance representing the UTC timestamp.
    :ivar baseline: 3x1 :class:`numpy.array` NED baseline vector from the fixed station to the receiver [m].
    :ivar Q: integer, GNSS solution quality level.
    :ivar nsat: integer, number of valid satellites.
    :ivar cov: 3x3 :class:`numpy.array` NED solution covariance matrix.
    """
    zupt = None

    def __init__(self, time, baseline, vel, Q, nsat, cov):
        self.time = time
        self.baseline = baseline
        self.vel = vel
        self.Q = Q
        self.nsat = nsat
        self.cov = cov

    def print(self):
        """Print epoch data."""
        print(self.time)
        print("NED = " + str(self.baseline))
        print("Q = " + str(self.Q))
        print("nsat = " + str(self.nsat))

def read_imu(path):
    with open(path, 'r') as file:
        print("Reading IMU data from " + path)

        """Read an IMU .txt file exported by MT Manager"""
        line = file.readline()
        while not "Packet" in line:
            line = file.readline()
        data = []
        while line:
            line = file.readline()
            frame = line.split()
            if len(frame) < 12:
                continue
            date = [int(num) for num in frame[1].split('/')]
            time = frame[2].split(':')
            secs = time[2].split('.')
            # print(time)
            # print(secs)
            timestamp = dt.datetime(date[0], date[1], date[2], int(
                time[0]), int(time[1]), int(secs[0]), int(int(secs[1]) / 1000))
            timestamp = timestamp + \
                dt.timedelta(0, 0, 0, t_delay_msec, 0, 0, 0)
            acc = np.array(
                [float(frame[3]), float(frame[4]), float(frame[5])])
            gyr = np.array(
                [float(frame[6]), float(frame[7]), float(frame[8])])
            mag = np.array(
                [float(frame[9]), float(frame[10]), float(frame[11])])
            quat = np.array([float(frame[12]), float(
                frame[13]), float(frame[14]), float(frame[15])])
            data.append(IMU_epoch(timestamp, acc, gyr, mag, quat))
        print("Read " + str(len(data)) + " IMU epochs from " + path)
        return data


def read_gnss(path, get_header=False, get_lla=False):
    """Read a GNSS .pos file generated by RTKlib"""
    file = open(path, 'r')
    lla0 = None
    lla0_line = None
    if get_header:
        header = []
    while True:
        line = file.readline()
        if "ref pos" in line:
            lla0_line = line
        if get_header:
            header.append(line)
        if "e-baseline(m)" in line:
            break
    data = []
    timestamp_prev = None
    baseline_prev = None
    while line:
        line = file.readline()
        frame = line.split()
        if len(frame) < 15:
            continue
        date = [int(num) for num in frame[0].split('/')]
        time = frame[1].split(':')
        secs = time[2].split('.')
        timestamp = dt.datetime(date[0], date[1], date[2], int(
            time[0]), int(time[1]), int(secs[0]), int(int(secs[1]) * 1000))
        baseline = np.array(
            [float(frame[3]), float(frame[2]), -float(frame[4])])
        Q = int(frame[5])
        nsat = int(frame[6])
        cov = np.array([[float(frame[8]), float(frame[10]), float(frame[11])],
                        [float(frame[10]), float(frame[7]), float(frame[12])],
                        [float(frame[11]), float(frame[12]), float(frame[9])]])
        scov = np.sign(cov)  # Extract covariance matrix element signs
        cov = np.square(cov)
        cov = np.multiply(scov, cov)
        if not timestamp_prev:
            vel = np.array(3 * [0.0])
        else:
            vel = (baseline - baseline_prev) / \
                (timestamp - timestamp_prev).total_seconds()
        data.append(GNSS_epoch(timestamp, baseline, vel, Q, nsat, cov))
        baseline_prev = baseline
        timestamp_prev = timestamp
    file.close()

    if lla0_line is not None:
        lla0 = lla0_line.split()[4:]
        lla0 = [float(i) for i in lla0]
        if len(lla0) == 7:
            # Convert LLA from degrees, minutes, seconds to decimal degrees
            lla0 = (lla0[0] + lla0[1]/60 + lla0[2]/3600,
                    lla0[3] + lla0[4]/60 + lla0[5]/3600, lla0[6])
        else:
            # If LLA is already in decimal degrees
            lla0 = (lla0[0], lla0[1], lla0[2])
        # print("Reference position (LLA): " + str(lla0))

    if get_header:
        lla0 = header
    return data, lla0, lla0_line